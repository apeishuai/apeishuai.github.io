<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>series-engineer on Wxf`s Fantasy World</title>
    <link>https://example.org/tags/series-engineer/</link>
    <description>Recent content in series-engineer on Wxf`s Fantasy World</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 16 Apr 2025 18:33:16 +0800</lastBuildDate>
    <atom:link href="https://example.org/tags/series-engineer/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>技能习得与提升</title>
      <link>https://example.org/resource/%E6%8A%80%E8%83%BD%E4%B9%A0%E5%BE%97%E4%B8%8E%E6%8F%90%E5%8D%87/</link>
      <pubDate>Wed, 16 Apr 2025 18:33:16 +0800</pubDate>
      <guid>https://example.org/resource/%E6%8A%80%E8%83%BD%E4%B9%A0%E5%BE%97%E4%B8%8E%E6%8F%90%E5%8D%87/</guid>
      <description>从给 RisingWave 提 PR 说起，聊聊怎么快速切入一个复杂的开源项目&#xA;这段时间学习c++，主要看&amp;lt;c++ primer&amp;gt; &amp;lt;c++ primer plus&amp;gt;两本，在这个过程中，对技能习得有一些感悟。&#xA;新手入门最大的问题是不知道关注点，这样会导致看很多跟目标无关的资料，运气好的话一段时间后能梳理出该领域图景，运气不好可能需要很长时间。&#xA;所以好的教程会给一张大图，然后针对大图给几个抓手，就能基本入门，然后碰到什么场景就学哪些工具，效率高。&#xA;1 把该领域最权威的资料都翻了，关注点在哪也能出来，就是耗时间。&#xA;然后是技能的巩固和练习，练习的目的是增加熟练度，分为两层，一层是基础技能，比如写个tcp通信，写个基础的排序算法；第二层是对需求建模，看到目标，在心里盘算怎么把基础的东西组合，得到一个想要的结果。&#xA;具体操作：&#xA;2 模仿，需要通过模仿练手感，熟悉基础知识点&#xA;3 技能练习：让ai给出练习题&#xA;犯错触发反馈：&#xA;4 在训练的时候尽量用自己的语言去写，这样能暴露当前的理解和最好模型之间的gap，得到修正方向。&#xA;5 检测掌握情况：能否根据名字带出很多细节&#xA;6 检查是否理解：能否用自己的话说出来&#xA;可能空间，声明周期 闭环+验证 数据间的变化关系 用项目学习 目标不清晰 6 学习速度测算 一般只需要获取大图和抓手，每个小项做针对性练习，比如平均做两个吧，就能算出自己的学习速度，然后安排工作即可。&#xA;但学习是非线性的，一个知识点可能要间隔重复三遍才能完全掌握，碰到场景不全的情况会pending很久。 对此的策略是：&#xA;a 要留痕，原始资料，二次加工，得出的一些成果，都要留痕。&#xA;b 检查对材料的吸收程度，哪怕一篇很简单的文章深究也会牵扯到很多细节，看要探究多深。&#xA;c 检查自己的思维，如果大脑的概念和逻辑链，及自身的技能不能满足需求，说明这两块得继续扩展。&#xA;练习分为两种方式，一种是交互式的，一种是大脑中演练。熟练度由脑中相关的神经链路决定，可以想象最初的链路是文字、行为激活的，当链路成型后，只是在大脑中不断演练，也有很好的提升效果。&#xA;经过这么久的实践，目前理解学习就是压缩信息，确定一个范围，确定该范围所有的输入输出，用尽可能好的结构组织这些输入输出。所以习得有一个概念展开在收缩的过程。&#xA;进入任何一个领域，按照我上面说的找出该领域的知识结构，在知识结构的基础上找出行业最佳实践，就能躺着玩了。&#xA;学习–&amp;gt;掌握阶段 状态1：完全陌生 看资料，补充逻辑 状态2：能想起几个名词，但还是陌生 看资料，补充逻辑，动手实践 状态3：能用基本要素写一些简单功能，但只能覆盖很小一部分场景 (间接经验)补充使用场景，在场景中反复折叠逻辑，反复动手实践 状态4：能完成功能模块，但限于项目，有些场景依然无法覆盖 (直接经验)寻找这些场景，学习开源项目 状态5：能完成需求，但是无法主导项目 主动获取资源，拿到经验包，直面需求 状态6：掌握20%的核心知识(反复折叠得到)，覆盖80%的场景，并能分析场景给出方案 封装知识复用 </description>
    </item>
    <item>
      <title>学习理论v1.0</title>
      <link>https://example.org/resource/%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BAv1.0/</link>
      <pubDate>Sat, 15 Feb 2025 18:32:36 +0800</pubDate>
      <guid>https://example.org/resource/%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BAv1.0/</guid>
      <description>参考 wxf blog/project/学习专题，之前的文章比较散，这一篇结合实践重新组织一下逻辑。&#xA;阅读顺序：&#xA;学习工程化&#xA;主题阅读方法&#xA;材料覆盖率&#xA;领域驱动+搭积木&#xA;这个话题不想再提了。&#xA;1 学习 ！= 阅读、刷课&#xA;学习是有目的性的把对方的概念空间转化成自己的，一个概念包含大量的细节，需要反复折叠才能摸到概念的边界&#xA;唯一重要的是思想，思想是看事物的视角，基于此视角形成概念空间。概念是信息的压缩&#xA;所以如果要检验是否看到真东西，就把概念还原成场景，忘掉概念&#xA;2 学习需要状态&#xA;如上提到的，如果今天很困，或者不是很想看书，效率会很低&#xA;第一点要确保精力充足，睡好、吃好、玩好，心无杂念，效率是最高的&#xA;第二点要确保随时进入状态，B=MAT M很简单，热爱，能从中获得乐趣，或者说不得不学；T得设计，可以把两个动作串起来(行为链)，比如在GTD里面放数学题，或者埋几个外部触发的点(这两个都是很自然的触发器)；A的话需要降低行为过程中的阻力，需要：整块不被打扰的时间、笔记(留更多带宽给大脑思考)、实践平台&#xA;3 启发式学习&#xA;在工程实践过程中，更多的是没有方向。&#xA;效率最高的是问从业者，他们已经形成一套稳定的解决方案；第二是看源码；第三是阅读相关领域书籍、论文，穷举所有可能性，方案也就出来了(这个最怕的是视角不对，视角不对，很多概念出不来)&#xA;看源码或文献，从历史开始研究，效率最高&#xA;focus: 历史、已经出现的概念空间、各种影响因素&#xA;4 如何构建复杂逻辑&#xA;这个需要一个思维模型：一个框，所有遇到的概念或逻辑链丢到这个框里，等需要的时候再拿出来用。或者说时不时拿一两个出来做推演或观察(可能出现gap的情况)&#xA;要保证短逻辑链的稳固，需要在一个场景中能很纯熟的使用现有概念+工具解决问题 (类似于飞行员检查清单)、(这里建议看下《穷查理宝典》，有很多有用的工具)&#xA;ref git 飞行规则&#xA;在稳固的前提下扩展，尽量不影响原有逻辑。只要模型跟现实世界相符，偏底层，很少出现推倒重建的情况&#xA;5 实战流程&#xA;问题列表 问题–&amp;gt;框定范围–&amp;gt;资料搜集–&amp;gt;断语拼凑–&amp;gt;短逻辑链整理&amp;lt;–&amp;gt;练习、维持手感–&amp;gt;敲掉问题 资料搜集，参考“主题阅读” 断语拼凑，参考“文档池及搜索入口搭建” 短逻辑链整理，参考“demo，及开源代码阅读方法，简言之，先跑起来” 练习，参考“环境搭建”&#xA;现在特别喜欢工作里遇到不懂的问题，这意味着我当前的知识和问题之间，存在不少的gap点，我是这样“递归”来解决遇到的问题的：&#xA;把遇到的问题一个个写下来，形成一个“问题列表”（list of problem），对问题的描述越具体越好； 遍历第一步形成的“问题列表”，逐个解决。过程中记录、整理下来当前知识到解决这个问题之间，需要新增的知识点； 第2步解决问题时如果同样遇到了问题，同样按照第一步的流程，把解决这个问题时遇到的子问题添加到“问题列表”里； 重复以上三步，直到清空“问题列表”中的所有问题。 （附图中是这个流程的伪代码，但是不够准确，修改后的伪代码见评论）&#xA;四步下来之后，基本就完成了当前知识到问题之间，所有问题点的清理，以及新增知识点的整理。&#xA;知识点整理，需要落到具体的（文件）存储中，而不能仅仅局限于自己脑子里的“内存记忆”，而落到存储中需要有以下的要求：&#xA;条理化、结构化； 如果有可能，尽量增加图形化描述； 时常回顾，确保每次回顾都能看懂以前的表述，如果没有就修改或者润色。 整个流程的重点是：&#xA;把大的问题，划分成一个个的子问题，划分的标准是：是否能够解决这个子问题，如果不能就接着划分，让大的不能直接解决的问题“越具体越好”。 解决问题的过程中，把缺失的知识点整理补上，这样以后遇到类似的问题就能直接解决了。将原有的知识和新增的知识连接起来。 5 学习策略 学习应该抓重点，抓住几个核心概念，其余的知识点用实践场景慢慢刷新、巩固。这要求主动引入场景 6 分形与自举&#xA;7 误区</description>
    </item>
    <item>
      <title>学习工程化</title>
      <link>https://example.org/resource/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%8C%96/</link>
      <pubDate>Wed, 13 Nov 2024 18:32:22 +0800</pubDate>
      <guid>https://example.org/resource/%E5%AD%A6%E4%B9%A0%E5%B7%A5%E7%A8%8B%E5%8C%96/</guid>
      <description>不知从何说起，首先说两个观察：&#xA;1 很多时候人是在不断重复自己，重复固定的行为模式 2 很多人在自己不熟悉的领域表现的很“慢”&#xA;基于此，我提出学习工程化的方法，以解决兴趣太广泛的问题。&#xA;流程：原始材料–&amp;gt;加工–&amp;gt;提取(适配场景)&#xA;在遇到具体场景的时候，我发现很多知识点提取不出来，三个原因：&#xA;1 不能即时接触(行为设计角度来讲，阻碍越大，行为就越小几率出现)&#xA;2 加工后的材料应该结构化，形成一组组完整的概念空间&#xA;3 已经经历的场景生成的概念空间应该保存，以便后期复用&#xA;做一套机制，解决上述三个问题，就能不间断学习，且学习速度越来越快。&#xA;问题1，我的解决方式是:&#xA;md文档归纳知识点，坚果云同步至不同设备，docsify建站分享&#xA;问题2，我的解决方式是通过反复折叠，跑通流程，并将关键点记录在上述md文档中，文档归类完毕，应用频率高的知识点往文档顶部走，时间一长，使用频率高的知识点就都顶到头部了。&#xA;问题3，我觉得很有必要形成自己的名称空间，你得想办法去实现这些名字代表的具体内容，并将其固化。bash脚本实现书签管理&#xA;通过bash脚本接管所有操作。或者一直建立并维护资源类通道&#xA;我的常用名称空间大概这样&#xA;通过上述三个动作，就能把除了材料加工，场景外的所有内容都交出去。&#xA;在没有场景的时候可以通过材料加工构建逻辑链，有场景的时候直接提取，完善修正。&#xA;这是操作流程化，涉及到数学知识，计算类的，也要固化成概念，碰到具体场景直接使用做好的概念就成。&#xA;end&#xA;留存 文档分类&#xA;1 保留最原始出处&#xA;2 分层组织，运用para规则，+article 学习工程化提到的第三点：构建自己的命名空间&#xA;3 检索历史也要保存到log文件，追加至留存文档&#xA;问题1： 建一个大文件夹，保存内容如下&#xA;简悦自动保存离线网页，丢进去&#xA;聊天记录定期导出，丢进去&#xA;使用频率较高的pdf，丢进去&#xA;md(我试了，可以展示图片，也可以用latex显示数学公式)或org格式写的笔记，丢进去&#xA;工程文件，丢进去&#xA;这样，基本所有的文档都汇到一个池子了&#xA;问题2：&#xA;这里主要是笔记和工程类文件&#xA;笔记以doc-area分类，比如doc-dianqi，doc-jixie，doc-front，doc-soft，doc-host，etc&#xA;工程类文件建pro文件夹，按项目分&#xA;检索 经过上面的操作，可以确保文件库大部分文件是文本格式，然后找一个文本检索工具，作为检索入口&#xA;recoll，它可以扫描这些文本文件，生成索引表，很快能检索出需要的文本信息&#xA;fix:2024/12/05&#xA;引入rga，scoop install rga，可以点对点搜索，命令行也更符合使用习惯&#xA;fix:2026/01/14&#xA;引入filelocator，search pdf , search-yacy, search my pkm&#xA;对学习和知识的看法 学习就是建模，跟之前提的构建逻辑链相似。穷举所有状态，让这些状态全部包含在构建的模型当中，就获得了对这个状态空间的控制力&#xA;最难的地方在确定最终状态、找出影响要素&#xA;假设观测到某种现象，这种现象受到三个要素影响，即使想到了这三个要素，也很难去验证&#xA;从0知识出发，建立复杂系统，注定有很长的路要走。&#xA;构建的这个叫pkm系统，它解决的是过往经验复用的问题，做时间的朋友。</description>
    </item>
    <item>
      <title>领域驱动&#43;搭积木</title>
      <link>https://example.org/resource/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8&#43;%E6%90%AD%E7%A7%AF%E6%9C%A8/</link>
      <pubDate>Tue, 02 Apr 2024 18:31:58 +0800</pubDate>
      <guid>https://example.org/resource/%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8&#43;%E6%90%AD%E7%A7%AF%E6%9C%A8/</guid>
      <description>材料覆盖率 log:材料覆盖率章节增加材料索引相关内容&#xA;如何保证材料覆盖率？&#xA;所有的东西都是为了满足某些需求，人为创造出来的，所以需要知道这套控制方案产生的驱动力是什么，在创造这一套控制框架的过程中，是如何选取组织材料的，有哪些取舍，效果如何，未来如何演化&#xA;降一层，自己构建出这个工具，(原子语言、基于原子语言构建的一个平台类的东西)&#xA;然后以该工具提供的接口为基础，在不同场景的应用；如何确保构建的程序可控(基于SDK，再做一层抽象，为了满足具体业务)&#xA;应用过程中出现的问题及排查措施、解决方案(补全2中的逻辑、工程漏洞)&#xA;最终得到的是一个不人为干预，完美运行的机器(理想状态)，事实上，没有完美的系统&#xA;材料覆盖率，说的就是材料中上面四个层次信息的覆盖情况。&#xA;step1:&#xA;因为信息都是人产出的，要么是网页形式，要么是书本，视频。&#xA;找该领域的20-30人，把他们产出的所有资料遍历一遍，这样做的目的是画一张大图，标几个关键点。&#xA;具体操作：搜索：电气设计 xxx，然后必然会搜出些书、知乎文章类似的，顺藤摸瓜，把里面提到的所有参考资料、人汇聚到一起，凑够30个，就大功告成了&#xA;实际操作：&#xA;ref 自定义搜索引擎&#xA;参考这篇文章，把平时索引搜集到的使用频率较高、内容质量相对比较高的网站放到google的自定义搜索引擎，可大大提升检索效率&#xA;ref 搭建个人文档池&#xA;实例：&#xA;在想办法解决qt界面自适应的时候，直接从google搜索，效率很低；在博客园搜，大概半个小时找到了解决方案。所以自定义搜索引擎可以加速从未知到已知的速度。&#xA;还有一个好处是可以不断积累，一切问题从已积累的材料入手，清晰划出了个人能力的边界，如果问题超出了能力圈，也知道怎么扩展能力圈。&#xA;还需要实践场景，解决的是从已知到熟练&#xA;step2:&#xA;无学习路径&#xA;通过各种方式搜集断语，用自己的话写下来–&amp;gt;凑逻辑链–&amp;gt;做练习，从不同角度检测逻辑链–&amp;gt;淘汰没用的概念，成熟的闭环逻辑封存备用(注：可能需要花很长时间)&#xA;搜集断语路径：&#xA;技术文档 &amp;gt; 博客 &amp;gt;&#xA;2024/03/16 实践–&amp;gt;技术文档–&amp;gt;书单(扩充概念)&#xA;step3:&#xA;用工程手段探测，分析系统，找系统的控制点。这样相当于把视角切入到系统内部，有庖丁解牛，不见全牛的感觉。&#xA;依然是上面提到的四个层次，关注三个点：基本要素、抽象机制、组合机制。一个系统肯定能分解成最基本的部分。这里主要解决一个方向的问题，费曼有句话，凡我不能创造，我就不能理解。&#xA;如果step1的覆盖率足够的话，应该是能解决方向的问题，如果不行就求助有经验的员工，学习他们debug的思路，补全这块知识&#xA;2024/07/21 搜素proteus仿真相关书籍，内容有：所有功能介绍(当手册看)，经典电路，proteus构建仿真的思路及流程(此为上述覆盖率的一个实例)&#xA;2024/07/27 出现找一个资料死也找不到的情况，这时候要check下文档搜集路径(即网络)&#xA;2024/12/13 给出具体的索引方案，更新step1&#xA;领域驱动+搭积木 说说我是怎么学习c语言的。&#xA;我认为c语言是构建出的工具，为了使用好这个工具，得往下降一层，去学习编译器相关原理，但是也不用学的太多，有这么一张表足够，上面写了基本元素和语法规则、语义，此两者相当于象棋规则。&#xA;知晓规则后便是为了实现我们的目标，精心编排代码段。编排代码段跟搭积木类似，不管多复杂的逻辑，最终要回到这些基本要素，要做的是把相关的逻辑链跑通，然后看看人家是怎么搭积木的，用自己的方式实现一遍。&#xA;如此不断遍历，学会编程只是时间问题。但是，我在网上看到的c语言教学，都是教着写语句，++循环，乱七八糟的，那玩意用教么，给个表照着写不成吗，误人子弟&#xA;第二种是领域驱动，因为代码反映现实，跟具体领域相关，只有对编程的理解还不够，需补充领域相关知识，这时候需要请领域专家，一起建模，直到模型跑通了，产出产品为止。</description>
    </item>
    <item>
      <title>Eng Ref</title>
      <link>https://example.org/resource/eng-ref/</link>
      <pubDate>Tue, 21 Nov 2023 08:53:56 +0800</pubDate>
      <guid>https://example.org/resource/eng-ref/</guid>
      <description>再谈什么是软件架构&#xA;我手上有无数这种分析，一般我会写在evernote上，但前天正好在机场等飞机，写的时候手边访问evernote不方便，所以就改写到知乎上了。 我举这个例子是说，其实架构师手边是有大量的分析数据的，但必须能保证这些分析不会随意进入主分析链，避免目标被冲淡了。所以，你看到一点点的决策或者判断，实际上可能背后都是大量的工作。&#xA;就是要你懂TCP–半连接队列和全连接队列就是要你懂TCP–半连接队列和全连接队列&#xA;20240907 重读，作者确实对基础知识敲的比较深&#xA;如何在工作中学习&#xA;快速学习&#xA;什么是软件架构&#xA;浅谈最佳学习路径&#xA;Makefile概念入门&#xA;20240421 重读，为了更高的控制力，make工具一直在演化，最终给出一套完整的工程文件编译规则，适配所有平台。高屋建瓴，最重要的是“基于目标分层”的方式理解一个工具的思维，太牛逼了\&#xA;如何快速学习一项新技能？&#xA;如何学习一门技术&#xA;一款产品的从0到1之旅&#xA;从技术难题中学习&#xA;为什么在现实中学到的知识和观点，我自己无法成体系遵从逻辑得表达出来？&#xA;世界观和方法论&#xA;+The ‘illusion of knowledge’ that makes people overconfident //学会的&amp;quot;幻觉&amp;quot;&#xA;黑客的学习方法&#xA;099 高效学习：面对枯燥和量大的知识&#xA;SuperMemo 渐进学习大型指北</description>
    </item>
  </channel>
</rss>
